load time.maude
----------------------------------------------------------------------------------------
fmod ID is 
	pr STRING .
	sort Id .
	op id : String -> Id [ctor] .
endfm 

view Id from TRIV to ID is 
    sort Elt to Id .
endv
----------------------------------------------------------------------------------------
fmod FLOW is 
	pr ID .
	pr POSRAT-TIME-DOMAIN-WITH-INF .

	sort Flow .
	op flow : Id Time -> Flow [ctor] .
 
endfm 

view Flow from TRIV to FLOW is 
    sort Elt to Flow .
endv
----------------------------------------------------------------------------------------
fmod TOKEN is
	pr ID .
	pr POSRAT-TIME-DOMAIN-WITH-INF .
	sort Token .
	op token : Id Time -> Token [ctor] .
  
endfm

view Token from TRIV to TOKEN is 
    sort Elt to Token .
endv
----------------------------------------------------------------------------------------
fmod RESOURCE is
    pr ID .
    sort Resource .
    op resource : Id Nat Nat -> Resource [ctor] .
    
endfm

view Resource from TRIV to RESOURCE is 
    sort Elt to Resource .
endv

----------------------------------------------------------------------------------------
fmod GATEWAY is
    sort Gateway .
    op exclusive : -> Gateway [ctor] .
    op parallel : -> Gateway [ctor] .
endfm
----------------------------------------------------------------------------------------

fmod NODE is 
	pr SET{Id} .
	pr GATEWAY .
	pr STRING .
	pr POSRAT-TIME-DOMAIN-WITH-INF .
	
	sort Node .

	op start : Id Id -> Node [ctor] .
	op end : Id Id -> Node [ctor] .
	op task : Id String Id Id Time Set{Id} -> Node [ctor] .
	op split : Id Gateway Id Set{Id} -> Node [ctor] .
	op merge : Id Gateway Set{Id} Id -> Node [ctor] .

endfm

view Node from TRIV to NODE is 
    sort Elt to Node .
endv
----------------------------------------------------------------------------------------


mod BPMN-SEM is 
    pr POSRAT-TIME-DOMAIN-WITH-INF .
    pr STRING .

    pr SET{Flow} .
    pr SET{Id} .
    pr SET{Resource} .
    pr SET{Node} .
    pr SET{Token} .

    inc CONFIGURATION .
    sort Process .
    subsort Process < Cid .

    ---- class Process | nodes: Set{Node}, flows: Set{Flow}, tokens: Set{Token}, gtime: Time, resources: Set{Resource} .
    op Process : -> Process .
    op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
    op resources:_ : Set{Resource} -> Attribute [gather (&)] . 

    vars O : Oid .
    var N : Node .
    var N1 N2 N3 : Nat .
    vars T1 T2 T3 : Time .
    var Atts : AttributeSet .
    var Conf : Configuration .
    var TOKEN : Token .
    var id1 id2 id3 id4 id5 : Id .
    var NodeSet : Set{Node} .
    var FlowSet : Set{Flow} .
    var TokenSet : Set{Token} .
    var TaskName : String .
    var IdSet : Set{Id} .
    var ResourceSet : Set{Resource} .
    var R : Resource .
   

***************************************************************************************************************************************
  ---MERGE PARALLEL
***************************************************************************************************************************************
  ---Debe comprobarse que todos los tokens que estén en el idSet, tengan temp a 0
    op TokenSetInIdIsReady : Set{Token} Set{Id} -> Bool .
    eq TokenSetInIdIsReady (empty, IdSet) = true .
    eq TokenSetInIdIsReady ((token(id1, T1), TokenSet), IdSet) = 
        if id1 in IdSet then 
            T1 == 0 and TokenSetInIdIsReady(TokenSet, IdSet) 
        else 
            TokenSetInIdIsReady(TokenSet, IdSet)
        fi .
    
    ---prueba: red TokenSetInIdIsReady((token(id("00"), 0), token(id("01"), 0), token(id("02"), 0)), (id("00"), id("01"), id("02"))) .

    ---Debe eliminarse todos los tokens menos que pertenezcan al idSet
    op deleteTokensInIdSet : Set{Token} Set{Id} -> Set{Token} .
    eq deleteTokensInIdSet (empty, IdSet) = empty .
    eq deleteTokensInIdSet ((token(id1, T1), TokenSet), IdSet) = 
        if id1 in IdSet then 
            deleteTokensInIdSet(TokenSet, IdSet) 
        else 
            (token(id1, T1) , deleteTokensInIdSet (TokenSet, IdSet))
        fi .

    ---prueba: red deleteTokensInIdSet((token(id("00"), 0), token(id("03"), 0), token(id("02"), 0), token(id("06"), 0)), (id("00"), id("01"), id("02"))) .
***************************************************************************************************************************************
  ---SPLIT PARALLEL
***************************************************************************************************************************************
    
    --- se busca el tiempo de un flow dado un Id 
    op findTimeFromFlowSet : Set{Flow} Id -> Time .
    eq findTimeFromFlowSet (empty, id1) = 0 . --- no posible
    eq findTimeFromFlowSet (flow(id1, T1), id1) = T1 .
    ceq findTimeFromFlowSet ((flow(id2, T1), FlowSet),id1) = findTimeFromFlowSet(FlowSet, id1) if id2 =/= id1 .
    ---prueba: red findTimeFromFlowSet ((flow(id("00"), 15), flow(id("01"), 20), flow(id("02"), 10)), id("01")) .
  
  
    ---un token por cada flow inicializado el temporizador.
    op tokenParaCadaFlow : Set{Id} Set{Flow} -> Set{Token} .
    eq tokenParaCadaFlow (empty, FlowSet) = empty .
    eq tokenParaCadaFlow ((id1, IdSet), FlowSet) = token(id1, findTimeFromFlowSet(FlowSet, id1)), tokenParaCadaFlow(IdSet, FlowSet) .

   ---prueba red tokenParaCadaFlow((id("00"), id("01"), id("02")), (flow(id("00"), 15), flow(id("01"), 20), flow(id("02"), 30), flow(id("04"), 30))) .




 ***************************************************************************************************************************************
  ---RECURSOS
 ***************************************************************************************************************************************

    
    ---auxiliar
   op isResourceAvalible : Id Set{Resource} -> Bool .
   eq isResourceAvalible (id1, empty) = false . 
   eq isResourceAvalible (id1, (resource(id1, N2, N3), ResourceSet)) = if N3 >= 1 then true else false fi .
   eq isResourceAvalible (id1, (R, ResourceSet)) = isResourceAvalible(id1, ResourceSet) [owise] . 

   ---prueba: red isResourceAvalible((id("01")), (resource(id("00"), 1, 0), resource(id("01"), 1, 1), resource(id("02"), 1, 1))) .

    ---comprueba que tenga los recursos necesarios usando una función auxiliar
    op hasAvaliableResources : Set{Id} Set{Resource} -> Bool .
    eq hasAvaliableResources (empty) = true .
    eq hasAvaliableResources ((id1, IdSet), ResourceSet) = isResourceAvalible(id1, ResourceSet) and hasAvaliableResources(IdSet, ResourceSet) . ---true si tiene ese recurso y el resto
    
    ---prueba: red hasAvaliableResources((id("00"), id("01"), id("02")), (resource(id("00"), 1, 1), resource(id("01"), 1, 0), resource(id("02"), 1, 1))) .
    
    ---resta 1 a todos los recursos que estén del set de Id
    op reduceResources : Set{Id} Set{Resource} -> Set{Resource}.
    eq reduceResources (IdSet, empty) = empty .
    eq reduceResources (IdSet, (resource(id1, N1, s N2), ResourceSet)) =
    if id1 in IdSet then
        resource(id1, N1, N2), reduceResources(IdSet, ResourceSet)
    else 
        resource(id1, N1, s N2), reduceResources(IdSet, ResourceSet) 
    fi .
    ---no probado
   

***************************************************************************************************************************************
    ---TICK
***************************************************************************************************************************************
    op delta : Set{Token} Time -> Set{Token} .
    eq delta (empty, T1) = empty .
    ceq delta ((token(id1, T1),TokenSet), T2) = (token(id1, T1 monus T2), delta(TokenSet, T2)) if T1 gt T2 . ---No se si monus equivale a resta
    eq delta ((token(id1, T1), TokenSet), T2) = (token(id1, 0), delta(TokenSet, T2)) [owise] . ---Se supone que no vamos a tener nunca un valor que pueda dar negativo en el cronometro

    op mte : Set{Token} -> TimeInf .
    eq mte ((token(id1, T1), empty)) = T1 .
    eq mte ((token(id1, T1), (token(id2, T2), TokenSet))) = minimum(T1, mte((token(id2, T2), TokenSet))) .


	crl [tick] :
    	< O : Process | gtime: T1, tokens: (token(id1, T3), TokenSet), Atts >
    	=> < O : Process | gtime: T1 + T2, tokens: delta((token(id1, T3), TokenSet), T2), Atts >
	if T2 := mte((token(id1, T3), TokenSet)) /\ 0 < T2 .
 ***************************************************************************************************************************************
    --- REGLAS DE FLUJO
 ***************************************************************************************************************************************
	rl [startSession] : < O : Process | nodes: (start(id1, id2), NodeSet), 
		flows: (flow(id2, T1), FlowSet), tokens: (token(id1, 0), TokenSet), gtime: 0, Atts > 
	=> < O : Process | nodes: (start(id1, id2), NodeSet), 
		flows: (flow(id2, T1), FlowSet), tokens: (token(id2, T1), TokenSet), gtime: 0, Atts > .

	***token temporizador a 0, falta comprobar tiene el conjunto de recursos disponible (crl)
	crl [enterTask] : < O : Process | nodes: (task(id1, TaskName, id2, id3, T1, IdSet), NodeSet), 
		flows: (flow(id2, T2), FlowSet), tokens: (token(id2, 0), TokenSet), gtime: T3, resources: ResourceSet > 
	=> < O : Process | nodes: (task(id1, TaskName, id2, id3, T1, IdSet), NodeSet), 
		flows: (flow(id2, T2), FlowSet), tokens: (token(id1, T1), TokenSet), gtime: T3, resources: reduceResources(IdSet, ResourceSet) >
        if hasAvaliableResources(idSet, ResourceSet) .


	rl [enterFlowFromTask] : < O : Process | nodes: (task(id1, TaskName, id2, id3, T1, IdSet), NodeSet), 
		flows: (flow(id3, T2), FlowSet), tokens: (token(id1, 0), TokenSet), gtime: T3, Atts > 
	=> < O : Process | nodes: (task(id1, TaskName, id2, id3, T1, IdSet), NodeSet), 
		flows: (flow(id3, T2), FlowSet), tokens: (token(id3, T2), TokenSet), gtime: T3, Atts > .

  	rl [enterEnd] : < O : Process | nodes: (end(id1, id2), NodeSet), 
		flows: (flow(id2, T2), FlowSet), tokens: (token(id2, 0), TokenSet), gtime: T3, Atts > 
  	=> < O : Process | nodes: (end(id1, id2), NodeSet), 
		flows: (flow(id2, T2), FlowSet), tokens: (token(id1, 0), TokenSet), gtime: T3, Atts > .

    --- Or with multiple inputs
    crl [ExclusiveMerge] : < O : Process | nodes: (merge(id1, exclusive, IdSet, id4), NodeSet), 
		flows: (flow(id2, T1), flow(id4, T2), FlowSet), tokens: (token(id2, 0), TokenSet), gtime: T3, resources: ResourceSet > 
	=> < O : Process | nodes: (merge(id1, exclusive, IdSet, id4), NodeSet), 
		flows: (flow(id2, T1), flow(id4, T2), FlowSet), tokens: (token(id4, T2), TokenSet), gtime: T3, resources: ResourceSet > 
    if id2 in IdSet .

    --- Or with multiple outputs
    crl [ExclusiveSplit] : < O : Process | nodes: (split(id1, exclusive, id2, IdSet), NodeSet), 
		flows: (flow(id2, T1), flow(id3, T2), FlowSet), tokens: (token(id2, 0), TokenSet), gtime: T3, resources: ResourceSet > 
	=> < O : Process | nodes: (split(id1, exclusive, id2, IdSet), NodeSet), 
		flows: (flow(id2, T1), flow(id3, T2), FlowSet), tokens: (token(id3, T2), TokenSet), gtime: T3, resources: ResourceSet > 
    if id3 in IdSet .

    --- and input
    crl [ParallelMerge] : < O : Process | nodes: (merge(id1, parallel, IdSet, id4), NodeSet), 
		flows: (flow(id2, T1), flow(id4, T2), FlowSet), tokens: (token(id2, 0), TokenSet), gtime: T3, resources: ResourceSet > 
	=> < O : Process | nodes: (merge(id1, parallel, IdSet, id4), NodeSet), 
		flows: (flow(id2, T1), flow(id4, T2), FlowSet), tokens: (token(id4, T2), deleteTokensInIdSet(TokenSet,IdSet)), gtime: T3, resources: ResourceSet > 
    if TokenSetInIdIsReady((token(id2, 0), TokenSet), IdSet) . 

        ---and output
    rl [ParallelSplit] : < O : Process | nodes: (split(id1, parallel, id2, IdSet), NodeSet), 
		flows: (flow(id2, T1), FlowSet), tokens: (token(id2, 0), TokenSet), gtime: T3, resources: ResourceSet > 
	=> < O : Process | nodes: (split(id1, parallel, id2, IdSet), NodeSet), 
		flows: (flow(id2, T1), FlowSet), tokens: (tokenParaCadaFlow(IdSet,FlowSet), TokenSet), gtime: T3, resources: ResourceSet > .
    



endm 
