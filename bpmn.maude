load time.maude
----------------------------------------------------------------------------------------
fmod ID is 
	pr STRING .
	sort Id .
	op id : String -> Id [ctor] .
endfm 

view Id from TRIV to ID is 
    sort Elt to Id .
endv
----------------------------------------------------------------------------------------
fmod FLOW is 
	pr ID .
	pr POSRAT-TIME-DOMAIN-WITH-INF .

	sort Flow .
	op flow : Id Time -> Flow [ctor] .
 
endfm 

view Flow from TRIV to FLOW is 
    sort Elt to Flow .
endv
----------------------------------------------------------------------------------------
fmod TOKEN is
	pr ID .
	pr POSRAT-TIME-DOMAIN-WITH-INF .
	sort Token .
	op token : Id Time -> Token [ctor] .
  
endfm

view Token from TRIV to TOKEN is 
    sort Elt to Token .
endv
----------------------------------------------------------------------------------------
fmod RESOURCE is
    pr ID .
    sort Resource .
    op resource : Id Nat Nat -> Resource [ctor] .
    
endfm

view Resource from TRIV to RESOURCE is 
    sort Elt to Resource .
endv

----------------------------------------------------------------------------------------
fmod GATEWAY is
    sort Gateway .
    op exclusive : -> Gateway [ctor] .
    op parallel : -> Gateway [ctor] .
endfm
----------------------------------------------------------------------------------------

fmod NODE is 
	pr SET{Id} .
	pr GATEWAY .
	pr STRING .
	pr POSRAT-TIME-DOMAIN-WITH-INF .
	
	sort Node .

	op start : Id Id -> Node [ctor] .
	op end : Id Id -> Node [ctor] .
	op task : Id String Id Id Time Set{Id} -> Node [ctor] .
	op split : Id Gateway Id Set{Id} -> Node [ctor] .
	op merge : Id Gateway Set{Id} Id -> Node [ctor] .

endfm

view Node from TRIV to NODE is 
    sort Elt to Node .
endv
----------------------------------------------------------------------------------------


mod BPMN-SEM is 
    pr POSRAT-TIME-DOMAIN-WITH-INF .
    pr STRING .

    pr SET{Flow} .
    pr SET{Id} .
    pr SET{Resource} .
    pr SET{Node} .
    pr SET{Token} .

    inc CONFIGURATION .
    sort Process .
    subsort Process < Cid .

    ---- class Process | nodes: Set{Node}, flows: Set{Flow}, tokens: Set{Token}, gtime: Time, resources: Set{Resource} .
    op Process : -> Process .
    op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
    op resources:_ : Set{Resource} -> Attribute [gather (&)] . 

    vars O : Oid .
    var N : Node .
    var N1,N2,N3 : Nat .
    vars T1 T2 T3 : Time .
    var Atts : AttributeSet .
    var Conf : Configuration .
    var TOKEN : Token .
    var id1 id2 id3 id4 id5 : Id .
    var NodeSet : Set{Node} .
    var FlowNode : Set{Flow} .
    var TokenSet : Set{Token} .
    var TaskName : String .
    var IdSet : Set{Id} .
    var ResourceSet : Set{Resource} .
    var R : Resource .


   op isResourceAvalible : Id Set{Resource} -> Bool .
   eq isResourceAvalible (Id1,empty) = false . --- no lo encuentra, por tanto es falso
   eq isResourceAvalible(Id1,(resource(Id1,n2,n3),ResourceSet)) = if n3 > 1 then true else false fi. ---lo encuentra
   eq isResourceAvalible(Id1,(R,ResourceSet)) = isResourceAvalible(Id1,ResourceSet) [owise]. --- si el id no es el mismo, busca el siguiente

    ***repasar
    op hasAvaliableResources :  -> Bool .
    eq hasAvaliableResources ((id1,IdSet), ResourceSet) = isResourceAvalible(id1,ResourceSet) and hasAvaliableResources(IdSet,ResourceSet) . ---true si tiene ese recurso y el resto
    eq hasAvaliableResources (IdSet,ResourceSet) = true [owise] . --- IdSet == empty = true

    op reduceResources : Set{Id} Set{Resource} -> Set{Resource}.

    op delta : Set{Token} Time -> Set{Token} .
    eq delta (empty, T1) = empty .
    ceq delta ((token(id1, T1),TokenSet), T2) = (token(id1, T1 monus T2), delta(TokenSet, T2)) if T1 gt T2 . ---No se si monus equivale a resta
    eq delta ((token(id1, T1), TokenSet), T2) = (token(id1, 0), delta(TokenSet, T2)) [owise] . ---Se supone que no vamos a tener nunca un valor que pueda dar negativo en el cronometro

    op mte : Set{Token} -> TimeInf .
    eq mte ((token(id1, T1), empty)) = T1 .
    eq mte ((token(id1, T1), (token(id2, T2), TokenSet))) = minimum(T1, mte((token(id2, T2), TokenSet))) .


	crl [tick] :
    	< O : Process | gtime: T1, tokens: (token(id1, T3), TokenSet), Atts >
    	=> < O : Process | gtime: T1 + T2, tokens: delta((token(id1, T3), TokenSet), T2), Atts >
	if T2 := mte((token(id1, T3), TokenSet)) /\ 0 < T2 .
    
  
	rl [startSession] : < O : Process | nodes: (start(id1, id2), NodeSet), 
		flows: (flow(id2, T1), FlowNode), tokens: (token(id1, 0), TokenSet), gtime: 0, Atts > 
	=> < O : Process | nodes: (start(id1, id2), NodeSet), 
		flows: (flow(id2, T1), FlowNode), tokens: (token(id2, T1), TokenSet), gtime: 0, Atts > .

	***token temporizador a 0, falta comprobar tiene el conjunto de recursos disponible (crl)
	rl [enterTask] : < O : Process | nodes: (task(id1, TaskName, id2, id3, T1, IdSet), NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token(id2, 0), TokenSet), gtime: T3, resources: ResourceSet > 
	=> < O : Process | nodes: (task(id1, TaskName, id2, id3, T1, IdSet), NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token(id1, T1), TokenSet), gtime: T3, resources: ResourceSet > .
    

	rl [enterFlowFromTask] : < O : Process | nodes: (task(id1, TaskName, id2, id3, T1, IdSet), NodeSet), 
		flows: (flow(id3, T2), FlowNode), tokens: (token(id1, 0), TokenSet), gtime: T3, Atts > 
	=> < O : Process | nodes: (task(id1, TaskName, id2, id3, T1, IdSet), NodeSet), 
		flows: (flow(id3, T2), FlowNode), tokens: (token(id3, T2), TokenSet), gtime: T3, Atts > .

  	rl [enterEnd] : < O : Process | nodes: (end(id1, id2), NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token(id2, 0), TokenSet), gtime: T3, Atts > 
  	=> < O : Process | nodes: (end(id1, id2), NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token(id1, 0), TokenSet), gtime: T3, Atts > .

    --- Or input
    crl [merge] : < O : Process | nodes: (merge(id1, exclusive, (id2, id3), id4), NodeSet), 
		flows: (flow(id5, T1), flow(id4, T2), FlowNode), tokens: (token(id5, 0), TokenSet), gtime: T3, resources: ResourceSet > 
	=> < O : Process | nodes: (merge(id1, exclusive, (id2, id3), id4), NodeSet), 
		flows: (flow(id5, T1), flow(id4, T2), FlowNode), tokens: (token(id4, T2), TokenSet), gtime: T3, resources: ResourceSet > 
    if id5 == id2 or id5 == id3 .

    --- Or output
    crl [split] : < O : Process | nodes: (split(id1, exclusive, id2, (id3, id4)), NodeSet), 
		flows: (flow(id2, T1), flow(id5, T2), FlowNode), tokens: (token(id2, 0), TokenSet), gtime: T3, resources: ResourceSet > 
	=> < O : Process | nodes: (split(id1, exclusive, id2, (id3, id4)), NodeSet), 
		flows: (flow(id2, T1), flow(id5, T2), FlowNode), tokens: (token(id5, T2), TokenSet), gtime: T3, resources: ResourceSet > 
    if id5 == id3 or id5 == id4 .
endm 