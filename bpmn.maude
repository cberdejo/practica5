load time.maude
----------------------------------------------------------------------------------------
fmod ID is 
	pr STRING .
	sort Id .
	op id : String -> Id [ctor] .
endfm 

view Id from TRIV to ID is 
    sort Elt to Id .
endv
----------------------------------------------------------------------------------------
fmod FLOW is 
	pr ID .
	pr POSRAT-TIME-DOMAIN-WITH-INF .

	sort Flow .
	op flow : Id Time -> Flow [ctor] .
 
endfm 

view Flow from TRIV to FLOW is 
    sort Elt to Flow .
endv
----------------------------------------------------------------------------------------
fmod TOKEN is
	pr ID .
	pr POSRAT-TIME-DOMAIN-WITH-INF .
	sort Token .
	op token : Id Time -> Token [ctor] .
  
endfm

view Token from TRIV to TOKEN is 
    sort Elt to Token .
endv
----------------------------------------------------------------------------------------
fmod RESOURCE is
    pr ID .
    sort Resource .
    op resource : Id Nat Nat -> Resource [ctor] .
    
endfm

view Resource from TRIV to RESOURCE is 
    sort Elt to Resource .
endv

----------------------------------------------------------------------------------------
fmod GATEWAY is
    sort Gateway .
    op exclusive : -> Gateway [ctor] .
    op parallel : -> Gateway [ctor] .
endfm
----------------------------------------------------------------------------------------

fmod NODE is 
	pr SET{Id} .
	pr GATEWAY .
	pr STRING .
	pr POSRAT-TIME-DOMAIN-WITH-INF .
	
	sort Node .

	op start : Id Id -> Node [ctor] .
	op end : Id Id -> Node [ctor] .
	op task : Id String Id Id Time Set{Id} -> Node [ctor] .
	op split : Id  Gateway Id Set{Id} -> Node [ctor] .
	op merge : Id Gateway Set{Id} Id -> Node [ctor] .

endfm

view Node from TRIV to NODE is 
    sort Elt to Node .
endv
----------------------------------------------------------------------------------------


mod BPMN-SEM is 
    pr POSRAT-TIME-DOMAIN-WITH-INF .
    pr STRING .

    pr SET{Flow} .
    pr SET{Id} .
    pr SET{Resource} .
    pr SET{Node} .
    pr SET{Token} .

    inc CONFIGURATION .
    sort  Process .
    subsort Process < Cid .

    ---- class Process | nodes: Set{Node}, flows: Set{Flow}, tokens: Set{Token}, gtime: Time, resources: Set{Resource} .
    op Process : -> Process .
    op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
    op resources:_ : Set{Resource} ->  Attribute [gather (&)] . 

    vars O : Oid .
    var N : Node .
    vars T1 T2 T3 : Time .
    var Atts : AttributeSet .
    var Conf : Configuration .
    var TOKEN : Token .
    var id1 id2 id3 id4 : Id .
    var NodeSet : Set{Node} .
    var FlowNode : Set{Flow} .
    var TokenSet : Set{Token} .
    var TaskName : String .
    var IdSet : Set{Id} .
    var ResourceSet : Set{Resource} .

    ---Debería utilizarse Timeinf?
    op delta : Set{Token} Time -> Set{Token} .
    eq delta (empty,T1) = empty .
    ceq delta ((token(id1,T1),TokenSet),T2) = (token(id1,T1 monus T2 ),delta(TokenSet,T2)) if T1 gt T2 . ---No se si monus equivale a resta
    eq delta ((token(id1,T1),TokenSet),T2) = (token(id1,0),delta(TokenSet,T2))[owise] . ---Se supone que no vamos a tener nunca un valor que pueda dar negativo en el cronometro

     ---Debería utilizarse Timeinf?
      ---Lo que he pensado de momento, es que el mte será igual al tiempo mínimo de los temporizadores de los tokens
    op mte : Set{Token}  -> Time .
    eq mte ( (token(id1,T1),token(id2,T2) ) ) = minimum(T1,T2) . ---creo que en time.maude existe una operación minimum
    eq mte ((token(id1,T1),token(id2,T2),TokenSet)) = minimum(T1,minimum(T2,mte(TokenSet))) .


  	---no funcina tick
	crl [tick] :
    	< O : Process | gtime: T1, tokens: TokenSet, Atts >
    	=> < O : Process | gtime: T1 + T2, tokens: delta(TokenSet,T2), Atts >
	if T2 := mte(TokenSet) /\ 0 < T2  .
  
	rl [startSession] :  < O : Process | nodes: (start(id1,id2),NodeSet), 
		flows: (flow(id2, T1), FlowNode), tokens: (token( id1,0 ), TokenSet), gtime: 0, Atts > 
	=> < O : Process | nodes: (start(id1,id2),NodeSet), 
		flows: (flow(id2, T1), FlowNode), tokens: (token( id2,T1 ), TokenSet), gtime: 0, Atts > .

	***token temporizador a 0, falta comprobar tiene el conjunto de recursos disponible (crl)
	rl [enterTask] : < O : Process | nodes: (task(  id1, TaskName, id2, id3 ,T1 ,IdSet ),NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token( id2,0 ), TokenSet), gtime: T3, resources: ResourceSet > 
	=>  < O : Process | nodes: (task( id1, TaskName, id2 ,id3 ,T1 ,IdSet ),NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token( id1,T1 ), TokenSet), gtime: T3,  resources: ResourceSet > .

	rl [enterFlowFromTask] :  < O : Process | nodes: (task(  id1 ,TaskName, id2, id3, T1, IdSet ),NodeSet), 
		flows: (flow(id3, T2), FlowNode), tokens: (token( id1,0 ), TokenSet), gtime: T3, Atts > 
	=>  < O : Process | nodes: (task( id1,TaskName,id2 ,id3 ,T1 ,IdSet ),NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token( id2,T2 ), TokenSet), gtime: T3, Atts > .

  	rl [enterEnd] :  < O : Process | nodes: (end( id1,id2 ),NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token( id2,0 ), TokenSet), gtime: T3, Atts > 
  	=>  < O : Process | nodes: (end(id1,id2),NodeSet), 
		flows: (flow(id2, T2), FlowNode), tokens: (token( id1,0 ), TokenSet), gtime: T3, Atts > .
endm 